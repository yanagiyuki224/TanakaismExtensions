#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

// --- KEYWORDS_START ---
const K = {
    "VAR": "変数宣言",
    "PRINT": "表示",
    "COMMENT": "コメント",
    "IF": "もし",
    "ELIF": "違ったら",
    "ELSE": "それ以外",
    "END": "終了"
};
// --- KEYWORDS_END ---

// 正規表現用にエスケープする関数
function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

const args = process.argv.slice(2);
if (args.length === 0) {
    console.log(`使い方: tanakaism <ファイル名.tanakaism>`);
    process.exit(1);
}

const filePath = path.resolve(process.cwd(), args[0]);

try {
    const code = fs.readFileSync(filePath, 'utf8');
    const lines = code.split(/\r?\n/);
    execute(lines);
} catch (e) {
    console.error("エラー:", e.message);
}

function evaluateCondition(condition, mem) {
    let evalStr = condition;
    for (let varName in mem) {
        const regex = new RegExp(`\\b${varName}\\b`, 'g');
        let val = mem[varName];
        evalStr = evalStr.replace(regex, typeof val === 'string' ? `"${val}"` : val);
    }
    try { return !!(eval(evalStr)); } catch (e) { return false; }
}

function findJumpTarget(lines, currentPc) {
    let depth = 0;
    const ifPattern = new RegExp(`^${escapeRegex(K.IF)}(\\s+|$)`);
    const elifPattern = new RegExp(`^${escapeRegex(K.ELIF)}(\\s+|$)`);
    
    for (let i = currentPc + 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.match(ifPattern)) { depth++; continue; }
        if (line === K.END) {
            if (depth === 0) return i;
            depth--;
            continue;
        }
        if (depth === 0 && (line.match(elifPattern) || line === K.ELSE)) return i;
    }
    return lines.length;
}

function findEndTag(lines, currentPc) {
    let depth = 0;
    const ifPattern = new RegExp(`^${escapeRegex(K.IF)}(\\s+|$)`);
    
    for (let i = currentPc + 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.match(ifPattern)) depth++;
        if (line === K.END) {
            if (depth === 0) return i;
            depth--;
        }
    }
    return lines.length;
}

function execute(lines) {
    let memory = {};
    let pc = 0;
    const totalLines = lines.length;
    console.log("--- ターミナル版田中イズム 実行開始 ---");

    while (pc < totalLines) {
        const line = lines[pc].trim();
        if (!line || line.startsWith(K.COMMENT)) { pc++; continue; }

        try {
            // 1. IF (もし)
            const ifMatch = line.match(new RegExp(`^${escapeRegex(K.IF)}\\s+(.*)`));
            if (ifMatch) {
                if (evaluateCondition(ifMatch[1], memory)) { pc++; } 
                else { pc = findJumpTarget(lines, pc); }
                continue;
            }
            
            // 2. ELIF / ELSE
            const elifMatch = line.match(new RegExp(`^${escapeRegex(K.ELIF)}(\\s+|$)`));
            if (elifMatch || line === K.ELSE) {
                pc = findEndTag(lines, pc);
                pc++;
                continue;
            }
            
            // 3. END (終了)
            if (line === K.END) { pc++; continue; }

            // 4. VAR (変数宣言)
            const varMatch = line.match(new RegExp(`^${escapeRegex(K.VAR)}\\s+(\\w+)\\s*=\\s*(.*)`));
            if (varMatch) {
                const varName = varMatch[1];
                let valStr = varMatch[2].trim();
                if (valStr.startsWith('"') && valStr.endsWith('"')) {
                    memory[varName] = valStr.slice(1, -1);
                } else {
                    let tempExpr = valStr;
                    for (let v in memory) {
                        tempExpr = tempExpr.replace(new RegExp(`\\b${v}\\b`, 'g'), memory[v]);
                    }
                    memory[varName] = eval(tempExpr);
                }
                pc++;
                continue;
            }

            // 5. PRINT (表示)
            const printMatch = line.match(new RegExp(`^${escapeRegex(K.PRINT)}\\s+(.*)`));
            if (printMatch) {
                let expr = printMatch[1].trim();
                let out = (expr.startsWith('"') && expr.endsWith('"')) ? expr.slice(1, -1) : (memory.hasOwnProperty(expr) ? memory[expr] : expr);
                console.log(out);
                pc++;
                continue;
            }

            console.log(`[Line ${pc+1}] 未知のコマンド: ${line}`);
        } catch (e) {
            console.error(`[Line ${pc+1}] 実行エラー: ${e.message}`);
        }
        pc++;
    }
    console.log("--- 実行終了 ---");
}