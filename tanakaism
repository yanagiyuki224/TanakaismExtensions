#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

// --- KEYWORDS_START ---
const K = {
    "VAR": "変数宣言",
    "PRINT": "表示",
    "INPUT": "受け取る",
    "LOOP": "ループ",
    "SCAN": "聞く",
    "COMMENT": "コメント",
    "IF": "もし",
    "ELIF": "違ったら",
    "ELSE": "それ以外",
    "END": "終了"
};
// --- KEYWORDS_END ---

function findLoopEnd(lines, currentPc) {
    let depth = 0;
    const startPattern = new RegExp(`^(${escapeRegex(K.LOOP)}|${escapeRegex(K.IF)})(\\s+|$)`);
    
    for (let i = currentPc + 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.match(startPattern)) {
            depth++;
        } else if (line === K.END) {
            if (depth === 0) return i;
            depth--;
        }
    }
    return lines.length;
}

function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

const args = process.argv.slice(2);
if (args.length === 0) {
    console.log(`使い方: tanakaism <ファイル名.tanakaism>`);
    process.exit(1);
}

const filePath = path.resolve(process.cwd(), args[0]);

try {
    const code = fs.readFileSync(filePath, 'utf8');
    const lines = code.split(/\r?\n/);
    execute(lines);
} catch (e) {
    console.error("エラー:", e.message);
}

function evaluateCondition(condition, mem) {
    let evalStr = condition;
    for (let varName in mem) {
        const regex = new RegExp(`\\b${varName}\\b`, 'g');
        let val = mem[varName];
        evalStr = evalStr.replace(regex, typeof val === 'string' ? `"${val}"` : val);
    }
    try { return !!(eval(evalStr)); } catch (e) { return false; }
}

function findJumpTarget(lines, currentPc) {
    let depth = 0;
    const ifPattern = new RegExp(`^${escapeRegex(K.IF)}(\\s+|$)`);
    const elifPattern = new RegExp(`^${escapeRegex(K.ELIF)}(\\s+|$)`);

    for (let i = currentPc + 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.match(ifPattern)) { depth++; continue; }
        if (line === K.END) {
            if (depth === 0) return i;
            depth--;
            continue;
        }
        if (depth === 0 && (line.match(elifPattern) || line === K.ELSE)) return i;
    }
    return lines.length;
}

function findEndTag(lines, currentPc) {
    let depth = 0;
    const ifPattern = new RegExp(`^${escapeRegex(K.IF)}(\\s+|$)`);

    for (let i = currentPc + 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.match(ifPattern)) depth++;
        if (line === K.END) {
            if (depth === 0) return i;
            depth--;
        }
    }
    return lines.length;
}

function execute(lines) {
    let memory = {};
    let pc = 0;
    let blockStack = [];
    const totalLines = lines.length;
    console.log("--- ターミナル版田中イズム 実行開始 ---");

    while (pc < totalLines) {
        const line = lines[pc].trim();
        if (!line || line.startsWith(K.COMMENT)) { pc++; continue; }

        try {
            // 1. LOOP (ループ)
            const loopMatch = line.match(new RegExp(`^${escapeRegex(K.LOOP)}\\s+(.*)`));
            if (loopMatch) {
                const condition = loopMatch[1];
                if (evaluateCondition(condition, memory)) {
                    // ループ開始位置と条件を記録
                    blockStack.push({ type: 'LOOP', startPc: pc, condition: condition });
                    pc++;
                } else {
                    // 条件不成立ならループの終わりまでジャンプ
                    pc = findEndTag(lines, pc) + 1;
                }
                continue;
            }

            // 2. IF (もし)
            const ifMatch = line.match(new RegExp(`^${escapeRegex(K.IF)}\\s+(.*)`));
            if (ifMatch) {
                if (evaluateCondition(ifMatch[1], memory)) {
                    blockStack.push({ type: 'IF', entered: true });
                    pc++;
                } else {
                    blockStack.push({ type: 'IF', entered: false });
                    pc = findJumpTarget(lines, pc); 
                }
                continue;
            }

            // 3. END (終了) - 修正版
            if (line === K.END) {
                const lastBlock = blockStack[blockStack.length - 1];
                
                if (lastBlock && lastBlock.type === 'LOOP') {
                    // ループの終了タグかどうかを確認
                    // ループの開始位置から対応する終了タグを探して、それが現在位置と一致するか確認
                    const loopEndPc = findEndTag(lines, lastBlock.startPc);
                    
                    if (loopEndPc === pc) {
                        // これはループの終了タグ
                        blockStack.pop();
                        if (evaluateCondition(lastBlock.condition, memory)) {
                            // 条件がまだ真ならループ開始位置に戻る
                            blockStack.push(lastBlock);
                            pc = lastBlock.startPc;
                        } else {
                            // 条件が偽になったらループを抜ける
                            pc++;
                        }
                    } else {
                        // ループ内のIF文の終了タグ
                        blockStack.pop();
                        pc++;
                    }
                } else if (lastBlock && lastBlock.type === 'IF') {
                    // IF文の終了タグ
                    blockStack.pop();
                    pc++;
                } else {
                    // スタックが空の場合
                    pc++;
                }
                continue;
            }

            // 4. ELIF / ELSE
            const elifMatch = line.match(new RegExp(`^${escapeRegex(K.ELIF)}\\s+(.*)`));
            if (elifMatch) {
                // ELIF は前の IF/ELIF が成功した場合にスキップ
                const lastBlock = blockStack[blockStack.length - 1];
                if (lastBlock && lastBlock.type === 'IF' && lastBlock.entered) {
                    // 前のブロックに入っていたらこのELIFをスキップ
                    pc = findEndTag(lines, pc) + 1;
                } else if (evaluateCondition(elifMatch[1], memory)) {
                    // 条件成立
                    if (lastBlock && lastBlock.type === 'IF') {
                        lastBlock.entered = true;
                    }
                    pc++;
                } else {
                    // 条件不成立、次のELIF/ELSEへ
                    pc = findJumpTarget(lines, pc);
                }
                continue;
            }
            
            if (line === K.ELSE) {
                const lastBlock = blockStack[blockStack.length - 1];
                if (lastBlock && lastBlock.type === 'IF' && lastBlock.entered) {
                    // 前のブロックに入っていたらこのELSEをスキップ
                    pc = findEndTag(lines, pc) + 1;
                } else {
                    // ELSEブロックに入る
                    if (lastBlock && lastBlock.type === 'IF') {
                        lastBlock.entered = true;
                    }
                    pc++;
                }
                continue;
            }

            // 5. VAR (変数宣言)
            const varMatch = line.match(new RegExp(`^${escapeRegex(K.VAR)}\\s+(\\w+)\\s*=\\s*(.*)`));
            if (varMatch) {
                const varName = varMatch[1];
                let valStr = varMatch[2].trim();
                if (valStr.startsWith('"') && valStr.endsWith('"')) {
                    memory[varName] = valStr.slice(1, -1);
                } else {
                    let tempExpr = valStr;
                    for (let v in memory) {
                        tempExpr = tempExpr.replace(new RegExp(`\\b${v}\\b`, 'g'), memory[v]);
                    }
                    memory[varName] = eval(tempExpr);
                }
                pc++;
                continue;
            }

            // 6. PRINT (表示)
            const printMatch = line.match(new RegExp(`^${escapeRegex(K.PRINT)}\\s+(.*)`));
            if (printMatch) {
                let expr = printMatch[1].trim();
                try {
                    let evalExpr = expr;
                    for (let v in memory) {
                        const regex = new RegExp(`\\b${v}\\b`, 'g');
                        const val = typeof memory[v] === 'string' ? JSON.stringify(memory[v]) : memory[v];
                        evalExpr = evalExpr.replace(regex, val);
                    }
                    console.log(eval(evalExpr));
                } catch (e) {
                    console.log(memory.hasOwnProperty(expr) ? memory[expr] : expr.replace(/"/g, ''));
                }
                pc++;
                continue;
            }

            // 7. INPUT (受け取る)
            const inputMatch = line.match(new RegExp(`^${K.INPUT}\\s+(\\w+)`));
            if (inputMatch) {
                const varName = inputMatch[1];
                process.stdout.write(`${varName} の値を入力してください: `);

                const buffer = Buffer.alloc(1024);
                const bytesRead = fs.readSync(0, buffer, 0, 1024);
                const userInput = buffer.toString('utf8', 0, bytesRead).trim();

                memory[varName] = isNaN(userInput) ? userInput : Number(userInput);
                pc++;
                continue;
            }

            // 8. SCAN (聞く)
            const scanMatch = line.match(new RegExp(`^(\\w+)\\s*=\\s*${escapeRegex(K.SCAN)}\\s+(.*)`));
            if (scanMatch) {
                const varName = scanMatch[1];
                let promptExpr = scanMatch[2].trim();

                let evalPrompt = promptExpr;
                for (let v in memory) {
                    const regex = new RegExp(`\\b${v}\\b`, 'g');
                    const val = typeof memory[v] === 'string' ? JSON.stringify(memory[v]) : memory[v];
                    evalPrompt = evalPrompt.replace(regex, val);
                }

                try {
                    const finalPrompt = eval(evalPrompt);
                    process.stdout.write(`${finalPrompt}: `);

                    const buffer = Buffer.alloc(1024);
                    const bytesRead = fs.readSync(0, buffer, 0, 1024);
                    const userInput = buffer.toString('utf8', 0, bytesRead).trim();

                    memory[varName] = isNaN(userInput) || userInput === "" ? userInput : Number(userInput);
                } catch (e) {
                    console.error(`質問内容のエラー: ${e.message}`);
                }
                pc++;
                continue;
            }

            console.log(`[Line ${pc + 1}] 未知のコマンド: ${line}`);
        } catch (e) {
            console.error(`[Line ${pc + 1}] 実行エラー: ${e.message}`);
        }
        pc++;
    }
    console.log("--- 実行終了 ---");
}